# A. Контекстный сова-управленец

## Ограничения
- Ограничение времени: 1 секунда
- Ограничение памяти: 64.0 Мб

## Формат ввода/вывода
- Ввод: стандартный ввод или input.txt
- Вывод: стандартный вывод или output.txt

## Условие
Самая простая задача из трех представленных, на субъективный взгляд лектора, конечно же.

В этой задаче вас просят написать контекстный менеджер, который умеет в рамках контекста переключать потоки ввода и ошибок. Он должен уметь исполнять следующий интерфейс:

```python
with stream_switcher(stdout=ToStdout, stderr=ToStderr):
   ...
```

Вам так же нужно реализовать три класса:
- ToStdout (вывод в стандартный поток)
- ToStderr (вывод в поток ошибок)
- ToDevnull (вывод в никуда)

Эти классы передаются в виде аргументов в контекстном менеджере.

## Примечания
Вам нужно загрузить файл, в котором будет только реализация менеджера и классов потоков. Импорт происходит так:

```python
from participantSolution import stream_switcher, ToStderr, ToStdout, ToDevnull
```

Обратите внимание, что за задачу могут ставиться не полные баллы. Подробнее смотрите в отчете.

[Решение](a.py)

---

# B. Генератор 220v

## Ограничения
- Ограничение времени: 10 секунд
- Ограничение памяти: 64.0 Мб

## Формат ввода/вывода
- Ввод: стандартный ввод или input.txt
- Вывод: стандартный вывод или output.txt

## Условие
Что будет если смешать:
- Регулярные выражения
- Генераторы Python
- Правила формирования email

ЭТА ЗАДАЧА!

Напомним, что email адрес представляется как local@domain.

Вам нужно написать генератор, который умеет генерировать email адрес. Генератор должен быть умный и уметь подстраиваться под наши хотели, чтобы, например, уметь генерировать адреса с разными айдишниками по маске 'chupov[1-9]*@mail\.ru':

```
chupov1@mail.ru
chupov99@mail.ru
...
```

Генератор может принимать на вход четыре опциональных аргумента:
```python
def email_generator(
    regex,      # строка с регулярным выражением для всего адреса
    local_mask, # строка с регулярным выражением для локального имени
    domain_mask, # строка с регулярным выражением для имени домена
    size        # количество элементов (если не указан, то генератор должен быть бесконечным)
)
```

Обратите внимание, ни один из параметров НЕ ЯВЛЯЕТСЯ обязательным. То есть может быть просто вызов `for i in email_generator()`

## Примечания
- Все регулярки в тестах заведомо подходят под стандарт RFC 5322
- В задаче можно использовать библиотеку rstr
- Вам нужно загрузить файл, в котором будет только реализация декоратора. Импорт происходит так:
```python
from participantSolution import email_generator
```
- Обратите внимание, что за задачу могут ставиться не полные баллы. Подробнее смотрите в отчете...

[Решение](b.py)

---

# C. Простенький декоратор (нет)

## Ограничения
- Ограничение времени: 1 секунда
- Ограничение памяти: 64.0 Мб

## Формат ввода/вывода
- Ввод: стандартный ввод или input.txt
- Вывод: стандартный вывод или output.txt

## Условие
Интересная задача, как и все остальные, но чуть-чуть интереснее. Вам необходимо написать декоратор `@logger_decorator`, который будет для ЛЮБОЙ функции логгировать в стандартный поток вывода информацию о функции в следующем формате:

```
Function name: func_name
Arguments: (args) {kwargs}
Return value: return_value
```

Под любой функцией могут подразумеваться:
- методы классов
- одиночные функции
- другие декораторы
- и т.д.

## Примечания
Вам нужно загрузить файл, в котором будет только реализация декоратора. Импорт происходит так:

```python
from participantSolution import logger_decorator
```

Обратите внимание, что за задачу могут ставиться не полные баллы. Подробнее смотрите в отчете...

[Решение](c.py)